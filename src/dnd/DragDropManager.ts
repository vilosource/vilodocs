import { LayoutAction } from '../state/layoutReducer';

export interface DragState {
  type: 'tab';
  tabId: string;
  sourceLeafId: string;
  dragElement: HTMLElement;
}

export interface DropTarget {
  leafId: string;
  position: 'center' | 'left' | 'right' | 'top' | 'bottom';
  bounds: { x: number; y: number; width: number; height: number };
}

export class DragDropManager {
  private dragState: DragState | null = null;
  private dropTarget: DropTarget | null = null;
  private dispatch: (action: LayoutAction) => void;
  private dropZoneThreshold = 0.25; // 25% of dimension for edge zones
  private nextLeafId = 1;

  constructor(dispatch: (action: LayoutAction) => void) {
    this.dispatch = dispatch;
  }

  startDrag(state: DragState): void {
    this.dragState = state;
    document.body.classList.add('dragging');
  }

  updateDropTarget(target: DropTarget | null): void {
    this.dropTarget = target;
  }

  endDrag(): void {
    if (!this.dragState || !this.dropTarget) {
      this.cancelDrag();
      return;
    }

    const { tabId, sourceLeafId } = this.dragState;
    const { leafId: targetLeafId, position } = this.dropTarget;

    // Handle different drop positions
    if (position === 'center') {
      // Drop in center - move tab to target leaf
      this.dispatch({
        type: 'MOVE_TAB',
        payload: {
          tabId,
          targetLeafId
        }
      });
    } else {
      // Drop on edge - split the target leaf first
      const direction = position === 'left' || position === 'right' ? 'horizontal' : 'vertical';
      const isAfter = position === 'right' || position === 'bottom';
      
      // Split the target leaf
      this.dispatch({
        type: 'SPLIT_LEAF',
        payload: {
          leafId: targetLeafId,
          direction,
          ratio: 0.5
        }
      });

      // The new leaf ID would be generated by the reducer
      // For now, we'll dispatch the move with a placeholder
      // In a real implementation, SPLIT_LEAF would return the new leaf ID
      const newLeafId = `editor-${this.nextLeafId++}`;
      
      // Move tab to the new leaf
      setTimeout(() => {
        this.dispatch({
          type: 'MOVE_TAB',
          payload: {
            tabId,
            targetLeafId: newLeafId
          }
        });
      }, 0);
    }

    this.cleanup();
  }

  cancelDrag(): void {
    this.cleanup();
  }

  isDragging(): boolean {
    return this.dragState !== null;
  }

  getDragState(): DragState | null {
    return this.dragState;
  }

  getDropTarget(): DropTarget | null {
    return this.dropTarget;
  }

  getDropPosition(x: number, y: number, bounds: { x: number; y: number; width: number; height: number }): 'center' | 'left' | 'right' | 'top' | 'bottom' {
    const relX = x - bounds.x;
    const relY = y - bounds.y;
    
    const leftThreshold = bounds.width * this.dropZoneThreshold;
    const rightThreshold = bounds.width * (1 - this.dropZoneThreshold);
    const topThreshold = bounds.height * this.dropZoneThreshold;
    const bottomThreshold = bounds.height * (1 - this.dropZoneThreshold);

    // Check edge zones first
    if (relX < leftThreshold) return 'left';
    if (relX > rightThreshold) return 'right';
    if (relY < topThreshold) return 'top';
    if (relY > bottomThreshold) return 'bottom';
    
    // Otherwise it's center
    return 'center';
  }

  createDragPreview(text: string): HTMLElement {
    const preview = document.createElement('div');
    preview.className = 'drag-preview';
    preview.textContent = text;
    preview.style.position = 'fixed';
    preview.style.pointerEvents = 'none';
    preview.style.zIndex = '10000';
    preview.style.opacity = '0.8';
    preview.style.padding = '4px 8px';
    preview.style.backgroundColor = 'var(--vscode-editor-background, #1e1e1e)';
    preview.style.color = 'var(--vscode-editor-foreground, #cccccc)';
    preview.style.border = '1px solid var(--vscode-focusBorder, #007acc)';
    preview.style.borderRadius = '3px';
    preview.style.fontSize = '13px';
    preview.style.whiteSpace = 'nowrap';
    
    document.body.appendChild(preview);
    return preview;
  }

  updatePreviewPosition(preview: HTMLElement, x: number, y: number): void {
    preview.style.left = `${x}px`;
    preview.style.top = `${y}px`;
  }

  private cleanup(): void {
    this.dragState = null;
    this.dropTarget = null;
    document.body.classList.remove('dragging');
  }
}